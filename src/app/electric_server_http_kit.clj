(ns app.electric-server-http-kit
  "preferred entrypoint (cleaner middleware for integration) but no java 8 compat"
  (:require [clojure.edn :as edn]
            [clojure.java.io :as io]
            [clojure.string :as str]
            [clojure.tools.logging :as log]
            [hyperfiddle.electric-httpkit-adapter :as adapter]
            [org.httpkit.server :as http-kit]
            [ring.middleware.basic-authentication :as auth]
            [ring.middleware.content-type :refer [wrap-content-type]]
            [ring.middleware.cookies :as cookies]
            [ring.middleware.params :refer [wrap-params]]
            [ring.middleware.resource :refer [wrap-resource]]
            [ring.util.response :as res])
  (:import (java.net BindException)))


(defn authenticate [username password] username)            ; demo (accept-all) authentication

(defn wrap-demo-authentication "A Basic Auth example. Accepts any username/password and store the username in a cookie."
  [next-handler]
  (-> (fn [ring-req]
        (let [res (next-handler ring-req)]
          (if-let [username (:basic-authentication ring-req)]
            (res/set-cookie res "username" username {:http-only true})
            res)))
    (cookies/wrap-cookies)
    (auth/wrap-basic-authentication authenticate)))


(defn wrap-demo-router "A basic path-based routing middleware"
  [next-handler]
  (fn [ring-req]
    (case (:uri ring-req)
      "/auth" (let [response ((wrap-demo-authentication next-handler) ring-req)]
                (if (= 401 (:status response))              ; authenticated?
                  response                                  ; send response to trigger auth prompt
                  (-> (res/status response 302)             ; redirect
                    (res/header "Location" (get-in ring-req [:headers "referer"]))))) ; redirect to where the auth originated
      ;; For any other route, delegate to next middleware
      (next-handler ring-req))))


(defn template "Takes a `string` and a map of key-values `kvs`. Replace all instances of `$key$` by value in `string`"
  [string kvs]
  (reduce-kv (fn [r k v] (str/replace r (str "$" k "$") v)) string kvs))


(defn get-modules [manifest-path]
  (when-let [manifest (io/resource manifest-path)]
    (let [manifest-folder (when-let [folder-name (second (rseq (str/split manifest-path #"\/")))]
                            (str "/" folder-name "/"))]
      (->> (slurp manifest)
        (edn/read-string)
        (reduce (fn [r module] (assoc r (keyword "hyperfiddle.client.module" (name (:name module))) (str manifest-folder (:output-name module)))) {})))))


(defn wrap-index-page
  "Server the `index.html` file with injected javascript modules from `manifest.edn`. `manifest.edn` is generated by the client build and contains javascript modules information."
  [next-handler resources-path manifest-path]
  (fn [ring-req]
    (if-let [response (res/resource-response (str resources-path "/index.html"))]
      (if-let [modules (get-modules manifest-path)]
        (-> (res/response (template (slurp (:body response)) modules)) ; TODO cache in prod mode
          (res/content-type "text/html")                    ; ensure `index.html` is not cached
          (res/header "Cache-Control" "no-store")
          (res/header "Last-Modified" (get-in response [:headers "Last-Modified"])))
        ;; No manifest found, can't inject js modules
        (-> (res/not-found "Missing client program manifest")
          (res/content-type "text/plain")))
      ;; index.html file not found on classpath
      (next-handler ring-req))))


(def ^:const VERSION (not-empty (System/getProperty "HYPERFIDDLE_ELECTRIC_SERVER_VERSION"))) ; see Dockerfile

(defn wrap-electric-websocket
  [next-handler entrypoint]
  (fn [req]
    (if (:websocket? req)
      (http-kit/as-channel req
        (let [client-version (get-in req [:query-params "HYPERFIDDLE_ELECTRIC_CLIENT_VERSION"])]
          (if (or (nil? VERSION) (= client-version VERSION))
            (adapter/handle-electric-ws req (partial adapter/electric-ws-message-handler req entrypoint))
            (adapter/reject-websocket-handler 1008))))      ; stale client - https://www.rfc-editor.org/rfc/rfc6455#section-7.4.1
      (next-handler req))))


(defn electric-websocket-middleware
  [next-handler entrypoint]
  (-> (wrap-electric-websocket next-handler entrypoint)     ; 3. connect electric client
    (cookies/wrap-cookies)                                  ; 2. makes cookies available to Electric app
    (wrap-params)))                                         ; 1. parse query params


(defn not-found-handler [_ring-request]
  (-> (res/not-found "Not found")
    (res/content-type "text/plain")))


(defn http-middleware [entrypoint resources-path manifest-path]
  ;; these compose as functions, so are applied bottom up
  (-> not-found-handler
    (wrap-index-page resources-path manifest-path)          ; 5. otherwise fallback to default page file
    (wrap-resource resources-path)                          ; 4. serve static file from classpath
    (wrap-content-type)                                     ; 3. detect content (e.g. for index.html)
    (wrap-demo-router)                                      ; 2. route
    (electric-websocket-middleware entrypoint)))            ; 1. connect electric client


(defn start-server!
  [entrypoint {:keys [port resources-path manifest-path]
               :or   {port           8080
                      resources-path "public"
                      manifest-path  "public/js/manifest.edn"}
               :as   config}]
  (if-let [server (try (http-kit/run-server (http-middleware entrypoint resources-path manifest-path)
                         (merge {:port port} config))
                       (catch BindException _err))]
    (do (println "\nðŸ‘‰ App server available at" (str "http://" (:host config) ":" port "\n"))
        server)
    (let [next-port (inc port)]
      ; port is already taken, retry with another one
      (log/warn "Port" port "was not available, retrying with" next-port)
      (recur entrypoint (assoc config :port next-port)))))


